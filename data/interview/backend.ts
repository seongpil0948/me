import type { InterviewQuestion } from "@/types/portfolio";

export const backendQuestions: InterviewQuestion[] = [
  {
    id: 16,
    category1: "Backend",
    category2: "Go vs Python",
    question: "Between Go and Python, which would you choose and why?",
    answer:
      "**Go vs Python 선택은 '시스템의 라이프사이클'을 고려해야 합니다.**\n\n**OpenTelemetry Custom Exporter 개발 경험:**\n\n당시 Python으로 프로토타입을 만들고 Go로 프로덕션 구현했는데, 이 과정에서 두 언어의 본질적 차이를 깨달았습니다.\n\n```python\n# Python 프로토타입 (2일 개발)\nclass CustomExporter:\n    def export(self, spans):\n        # 빠른 구현, 풍부한 라이브러리\n        metrics = self.analyze_spans(spans)\n        self.send_to_influxdb(metrics)\n        \n# 문제: GIL로 인한 concurrent export 병목\n# 20M spans/day 처리 시 CPU 사용률 80%+\n```\n\n```go\n// Go 프로덕션 버전 (1주 개발)\ntype CustomExporter struct {\n    batchProcessor *BatchProcessor\n    workerPool    chan struct{}\n}\n\nfunc (e *CustomExporter) ExportSpans(ctx context.Context, spans []Span) error {\n    // Goroutine pool로 concurrent processing\n    for _, batch := range e.batchSpans(spans, 1000) {\n        select {\n        case e.workerPool <- struct{}{}:\n            go func(batch []Span) {\n                defer func() { <-e.workerPool }()\n                e.processBatch(ctx, batch)\n            }(batch)\n        case <-ctx.Done():\n            return ctx.Err()\n        }\n    }\n}\n\n// 결과: CPU 사용률 15%, 메모리 사용량 50% 감소\n```\n\n**실제 프로덕션에서의 Trade-off 분석:**\n\n**Python의 강점을 활용한 사례:**\n\n```python\n# Airflow 기반 데이터 파이프라인\nfrom airflow.operators.python_operator import PythonOperator\n\ndef process_analytics_data():\n    # Pandas + NumPy 생태계 활용\n    df = pd.read_parquet('s3://analytics/raw-logs/')\n    \n    # 복잡한 비즈니스 로직 (30줄)\n    user_behavior = df.groupby(['user_id', 'session_id'])\\\n                     .agg({\n                         'event_time': ['min', 'max', 'count'],\n                         'page_path': lambda x: list(x.unique()),\n                         'conversion_value': 'sum'\n                     })\n    \n    # 결과: 개발 시간 1/3 단축, 가독성 확보\n```\n\n**Go의 강점을 활용한 사례:**\n\n```go\n// 고성능 Kafka Consumer\ntype StreamProcessor struct {\n    consumers []sarama.Consumer\n    processors []chan *sarama.ConsumerMessage\n}\n\nfunc (sp *StreamProcessor) ProcessMessages() {\n    // 50개 goroutine으로 parallel processing\n    for i := 0; i < 50; i++ {\n        go func(processorID int) {\n            for msg := range sp.processors[processorID] {\n                // 메시지 처리 (no GIL, true parallelism)\n                trace := sp.parseTraceFromKafka(msg.Value)\n                sp.storeToClickHouse(trace)\n            }\n        }(i)\n    }\n}\n\n// 결과: 20M messages/day → 50M messages/day 처리 가능\n```\n\n**언어 선택 의사결정 프레임워크:**\n\n**1. 개발 속도 vs 런타임 성능**\n```\nPython: 프로토타입 → MVP → 초기 스케일링\nGo: 검증된 로직 → 고성능 구현 → 장기 운영\n```\n\n**2. 팀 역량과 생태계**\n- **Python**: ML 엔지니어 협업, 데이터 분석팀과의 시너지\n- **Go**: 인프라팀 표준, Kubernetes ecosystem 호환성\n\n**3. 운영 복잡도**\n- **Python**: 의존성 지옥, 버전 관리 복잡성\n- **Go**: Static binary, 컨테이너화 최적화\n\n**현재 아키텍처 전략:**\n\n```\n┌─────────────┬─────────────┬─────────────┐\n│   Layer     │  Language   │   Reason    │\n├─────────────┼─────────────┼─────────────┤\n│ Data ETL    │   Python    │ Pandas/Numpy│\n│ API Gateway │     Go      │ Performance │\n│ Business    │   Python    │ Flexibility │\n│ Infra Tools │     Go      │ Reliability │\n└─────────────┴─────────────┴─────────────┘\n```\n\n**6개월 운영 후 교훈:**\n\n1. **Python**: 비즈니스 로직 변경이 잦은 영역에서 진가 발휘\n2. **Go**: 안정적인 요구사항, 고성능이 필요한 시스템에 최적\n3. **Polyglot architecture**: 각 언어의 강점을 활용한 하이브리드 접근\n\n핵심은 '기술 스택의 일관성'보다 '문제 도메인에 최적화'가 더 중요하다는 것입니다.",
  },
  {
    id: 17,
    category1: "Backend",
    category2: "Spring",
    question: "What is your Spring Boot experience?",
    answer:
      '**Spring Boot 마이크로서비스 운영에서 가장 어려운 것은 \'서비스 간 의존성 관리\'였습니다.**\n\n**Spring Cloud Eureka vs Service Mesh 아키텍처 딜레마:**\n\n₩500B 규모 이커머스 플랫폼을 운영하면서 직면한 핵심 문제:\n\n```java\n// 기존 Spring Cloud Eureka 방식\n@RestController\npublic class OrderController {\n    @Autowired\n    private PaymentServiceClient paymentClient;  // Feign Client\n    \n    @PostMapping("/orders")\n    public ResponseEntity<Order> createOrder(@RequestBody OrderRequest request) {\n        // 문제: Circuit breaker, retry, timeout을 각 서비스마다 구현\n        PaymentResponse payment = paymentClient.processPayment(\n            PaymentRequest.builder()\n                .amount(request.getAmount())\n                .userId(request.getUserId())\n                .build()\n        );\n        \n        // 서비스 디스커버리는 해결, 하지만 observability 부족\n        return ResponseEntity.ok(orderService.createOrder(request, payment));\n    }\n}\n```\n\n**APISIX Gateway 도입 결정 과정:**\n\n기존 Netflix Zuul → APISIX 마이그레이션 이유:\n\n```yaml\n# APISIX Route Configuration\nroutes:\n  - id: order-service\n    uri: /api/orders/*\n    upstream:\n      nodes:\n        "order-service:8080": 1\n      type: roundrobin\n    plugins:\n      prometheus:        # 메트릭 수집\n        prefer_name: true\n      limit-req:         # Rate limiting\n        rate: 100\n        burst: 50\n      cors:             # CORS 정책\n        allow_origins: "*"\n```\n\n**Trade-off 분석:**\n- **Spring Cloud Gateway**: JVM 생태계 통합, 하지만 메모리 사용량 높음\n- **APISIX**: Lua 기반 고성능, 하지만 Java 개발자에게 러닝커브\n- **최종 선택**: APISIX (throughput 3배 향상, 메모리 사용량 60% 감소)\n\n**Oracle DB + MyBatis 성능 최적화:**\n\n대용량 트랜잭션 처리에서 발견한 병목:\n\n```java\n// 문제: N+1 Query 문제\n@Mapper\npublic interface OrderMapper {\n    // 주문 1000건 조회 시 1000번의 추가 쿼리 발생\n    @Select("SELECT * FROM orders WHERE user_id = #{userId}")\n    List<Order> findByUserId(Long userId);\n    \n    @Select("SELECT * FROM order_items WHERE order_id = #{orderId}")\n    List<OrderItem> findItemsByOrderId(Long orderId);\n}\n\n// 해결: Batch fetching + Custom ResultMap\n@Mapper\npublic interface OptimizedOrderMapper {\n    @Select("""\n        SELECT o.*, oi.* \n        FROM orders o \n        LEFT JOIN order_items oi ON o.id = oi.order_id \n        WHERE o.user_id = #{userId}\n        ORDER BY o.created_at DESC\n    """)\n    @Results({\n        @Result(column = "id", property = "id"),\n        @Result(column = "id", property = "items", \n                many = @Many(select = "findItemsByOrderId"))\n    })\n    List<Order> findByUserIdOptimized(Long userId);\n}\n\n// 결과: 응답시간 2.3초 → 0.4초 (83% 개선)\n```\n\n**Circuit Breaker 패턴 구현:**\n\n```java\n@Component\npublic class PaymentServiceClient {\n    \n    @CircuitBreaker(name = "payment-service", fallbackMethod = "paymentFallback")\n    @TimeLimiter(name = "payment-service")\n    @Retry(name = "payment-service")\n    public CompletableFuture<PaymentResponse> processPaymentAsync(PaymentRequest request) {\n        return CompletableFuture.supplyAsync(() -> {\n            // External payment API 호출\n            return restTemplate.postForObject(\n                paymentServiceUrl + "/process", \n                request, \n                PaymentResponse.class\n            );\n        });\n    }\n    \n    public CompletableFuture<PaymentResponse> paymentFallback(\n            PaymentRequest request, Exception ex) {\n        // 장애 시 pending 상태로 처리 후 비동기 재시도\n        return CompletableFuture.completedFuture(\n            PaymentResponse.builder()\n                .status("PENDING")\n                .transactionId(UUID.randomUUID().toString())\n                .build()\n        );\n    }\n}\n```\n\n**실제 프로덕션 장애 경험과 교훈:**\n\n**장애 시나리오**: 결제 서비스 응답 지연 (5초+)\n**파급 효과**: 주문 서비스 thread pool 고갈 → 전체 시스템 다운\n**해결책**: \n1. **비동기 처리**: @Async + CompletableFuture\n2. **Thread pool 분리**: 결제용 별도 executor 구성\n3. **Graceful degradation**: 필수 기능만 유지\n\n```java\n@Configuration\n@EnableAsync\npublic class AsyncConfig {\n    \n    @Bean("paymentExecutor")\n    public Executor paymentExecutor() {\n        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();\n        executor.setCorePoolSize(10);\n        executor.setMaxPoolSize(50);\n        executor.setQueueCapacity(100);\n        executor.setThreadNamePrefix("Payment-");\n        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());\n        return executor;\n    }\n}\n```\n\n**Spring Boot Actuator 기반 모니터링:**\n\n```yaml\n# application.yml\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: health,metrics,prometheus,info\n  metrics:\n    export:\n      prometheus:\n        enabled: true\n  endpoint:\n    health:\n      show-details: always\n      \n# Custom Health Indicator\n@Component\npublic class DatabaseHealthIndicator implements HealthIndicator {\n    @Override\n    public Health health() {\n        try {\n            // Connection pool 상태 확인\n            int activeConnections = dataSource.getConnection().getMetaData()\n                .getMaxConnections();\n            \n            if (activeConnections > 80) {\n                return Health.down()\n                    .withDetail("reason", "Connection pool almost full")\n                    .withDetail("active", activeConnections)\n                    .build();\n            }\n            return Health.up().build();\n        } catch (Exception e) {\n            return Health.down(e).build();\n        }\n    }\n}\n```\n\n**6개월 운영 성과:**\n- **가용성**: 99.9% → 99.99% (장애 시간 90% 감소)\n- **응답 시간**: P95 기준 3.2초 → 0.8초\n- **처리량**: 10K TPS → 25K TPS (circuit breaker + async)\n\n핵심 교훈은 \'단일 장애점을 제거\'하고 \'시스템 경계를 명확히 정의\'하는 것이었습니다.',
  },
  {
    id: 18,
    category1: "Backend",
    category2: "Django",
    question: "What is your Django experience?",
    answer:
      "**Django를 선택한 이유는 '빠른 프로토타이핑'이었지만, 스케일링에서 한계를 경험했습니다.**\n\n**Virtual Try-on 프로젝트: AI 모델 통합의 도전**\n\n국가 과제로 진행한 가상 피팅룸에서 가장 어려웠던 것은 'ML 모델의 긴 추론 시간'과 'HTTP 요청-응답 모델'의 불일치였습니다.\n\n```python\n# 문제: 동기 처리로 인한 timeout\nclass TryOnView(APIView):\n    def post(self, request):\n        try:\n            # AI 모델 추론: 15-30초 소요\n            result = ml_model.generate_try_on(\n                user_image=request.FILES['user_photo'],\n                clothing_image=request.FILES['clothing']\n            )\n            return Response({'result_url': result.url})\n        except TimeoutError:\n            # 클라이언트 이미 연결 끊김\n            return Response({'error': 'timeout'}, status=408)\n```\n\n**Celery + Redis 비동기 아키텍처 설계:**\n\n```python\n# tasks.py - Celery worker\nfrom celery import Celery\nfrom django.core.cache import cache\n\napp = Celery('tryon')\n\n@app.task(bind=True)\ndef process_try_on(self, user_image_path, clothing_path, task_id):\n    try:\n        # 진행률 업데이트 (WebSocket으로 실시간 전송)\n        self.update_state(state='PROGRESS', meta={'current': 10, 'total': 100})\n        \n        # GPU 서버로 추론 요청\n        result = ml_model.inference(\n            user_image=user_image_path,\n            clothing=clothing_path,\n            callback=lambda progress: self.update_state(\n                state='PROGRESS', \n                meta={'current': progress, 'total': 100}\n            )\n        )\n        \n        # 결과를 S3에 저장 후 URL 반환\n        result_url = upload_to_s3(result.image_data)\n        \n        return {'status': 'SUCCESS', 'result_url': result_url}\n        \n    except Exception as exc:\n        # 실패 시 재시도 메커니즘\n        if self.request.retries < 3:\n            raise self.retry(countdown=60 * (2 ** self.request.retries))\n        raise exc\n\n# views.py - 비동기 API\nclass AsyncTryOnView(APIView):\n    def post(self, request):\n        # 즉시 task ID 반환\n        task = process_try_on.delay(\n            request.FILES['user_photo'].temporary_file_path(),\n            request.FILES['clothing'].temporary_file_path(),\n            str(uuid.uuid4())\n        )\n        \n        return Response({\n            'task_id': task.id,\n            'status_url': f'/api/tasks/{task.id}/status/',\n            'websocket_url': f'ws://localhost:8000/ws/tasks/{task.id}/'\n        })\n```\n\n**Django ORM 성능 최적화 경험:**\n\n사용자별 피팅 이력 조회에서 N+1 문제 해결:\n\n```python\n# Before: N+1 query 문제\nclass UserFittingHistory(APIView):\n    def get(self, request, user_id):\n        fittings = Fitting.objects.filter(user_id=user_id)  # 1 query\n        \n        results = []\n        for fitting in fittings:  # N queries\n            clothing = fitting.clothing  # DB hit\n            results.append({\n                'id': fitting.id,\n                'clothing_name': clothing.name,\n                'brand': clothing.brand.name,  # Another DB hit\n                'result_image': fitting.result_url\n            })\n        return Response(results)\n\n# After: select_related + prefetch_related\nclass OptimizedUserFittingHistory(APIView):\n    def get(self, request, user_id):\n        fittings = Fitting.objects\\\n            .filter(user_id=user_id)\\\n            .select_related('clothing', 'clothing__brand')\\\n            .prefetch_related('fitting_reviews')\\\n            .annotate(\n                avg_rating=Avg('fitting_reviews__rating'),\n                review_count=Count('fitting_reviews')\n            )\n        \n        # 단일 쿼리로 모든 데이터 조회\n        serializer = FittingHistorySerializer(fittings, many=True)\n        return Response(serializer.data)\n\n# 결과: 응답 시간 4.2초 → 0.3초 (93% 개선)\n```\n\n**Custom Authentication + JWT 구현:**\n\n```python\n# JWT + 소셜 로그인 하이브리드\nfrom rest_framework_simplejwt.tokens import RefreshToken\n\nclass SocialAuthView(APIView):\n    def post(self, request):\n        # 소셜 로그인 토큰 검증\n        social_token = request.data.get('social_token')\n        provider = request.data.get('provider')  # google, kakao, naver\n        \n        # Provider별 사용자 정보 획득\n        user_info = self.get_user_info_from_provider(social_token, provider)\n        \n        # Django User 생성 또는 조회\n        user, created = User.objects.get_or_create(\n            social_id=user_info['id'],\n            provider=provider,\n            defaults={\n                'username': user_info['email'],\n                'email': user_info['email'],\n                'first_name': user_info.get('name', '')\n            }\n        )\n        \n        # JWT 토큰 발급\n        refresh = RefreshToken.for_user(user)\n        access_token = refresh.access_token\n        \n        # 사용자별 맞춤 설정 로드\n        preferences = UserPreference.objects.get_or_create(user=user)[0]\n        \n        return Response({\n            'access_token': str(access_token),\n            'refresh_token': str(refresh),\n            'user': UserSerializer(user).data,\n            'preferences': PreferenceSerializer(preferences).data\n        })\n```\n\n**WebSocket + Django Channels 실시간 통신:**\n\n```python\n# consumers.py - WebSocket 핸들러\nfrom channels.generic.websocket import AsyncWebsocketConsumer\nimport json\n\nclass TryOnProgressConsumer(AsyncWebsocketConsumer):\n    async def connect(self):\n        self.task_id = self.scope['url_route']['kwargs']['task_id']\n        self.group_name = f'task_{self.task_id}'\n        \n        # 그룹 조인\n        await self.channel_layer.group_add(\n            self.group_name,\n            self.channel_name\n        )\n        await self.accept()\n    \n    async def disconnect(self, close_code):\n        await self.channel_layer.group_discard(\n            self.group_name,\n            self.channel_name\n        )\n    \n    # Celery task에서 진행률 업데이트 수신\n    async def task_progress(self, event):\n        await self.send(text_data=json.dumps({\n            'type': 'progress',\n            'current': event['current'],\n            'total': event['total'],\n            'message': event.get('message', '')\n        }))\n```\n\n**Django → FastAPI 마이그레이션 고려사항:**\n\n프로젝트 후반부에 FastAPI 검토했던 이유:\n\n```python\n# Django REST Framework\nclass TryOnViewSet(viewsets.ModelViewSet):\n    queryset = Fitting.objects.all()\n    serializer_class = FittingSerializer\n    # 장점: Admin, ORM, Ecosystem\n    # 단점: 비동기 지원 제한, 성능 오버헤드\n\n# FastAPI (검토만 함)\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n@app.post(\"/try-on\")\nasync def create_try_on(request: TryOnRequest):\n    # 장점: 네이티브 async, 높은 성능, 자동 문서화\n    # 단점: ORM 선택의 어려움, 생태계 미성숙\n    pass\n```\n\n**최종 Django 유지 결정 이유:**\n1. **프로젝트 일정**: 6개월 내 완성 필수\n2. **팀 역량**: Python/Django 전문성 보유\n3. **Admin interface**: 비개발자도 사용 가능한 관리 도구 필요\n4. **생태계**: ML 라이브러리와의 자연스러운 통합\n\n**6개월 운영 후 교훈:**\n- **Django의 강점**: 빠른 개발, 풍부한 생태계, 안정성\n- **한계**: 고성능 비동기 처리, 메모리 사용량\n- **해결책**: 핵심 로직은 Django, 고성능 부분은 별도 서비스로 분리\n\nDjango는 '비즈니스 로직의 복잡함'을 우아하게 처리하는 최고의 도구였습니다.",
  },
  {
    id: 19,
    category1: "Backend",
    category2: "Database",
    question: "What is your database experience?",
    answer:
      "**데이터베이스 설계에서 가장 중요한 것은 '액세스 패턴을 먼저 정의'하는 것입니다.**\n\n**Oracle DB: 이커머스 대용량 쿼리 최적화**\n\n₩500B 규모 플랫폼에서 직면한 핵심 문제:\n\n```sql\n-- 문제: 주문 조회 쿼리 (15초 소요)\nSELECT o.*, u.username, p.product_name, p.price\nFROM orders o\nJOIN users u ON o.user_id = u.id\nJOIN order_items oi ON o.id = oi.order_id\nJOIN products p ON oi.product_id = p.id\nWHERE o.created_at BETWEEN '2024-01-01' AND '2024-12-31'\nORDER BY o.created_at DESC;\n\n-- 분석: Explain Plan에서 Full Table Scan 발견\n-- 원인: created_at에 인덱스 없음, JOIN 순서 비최적화\n```\n\n**인덱싱 전략과 파티셔닝:**\n\n```sql\n-- 해결 1: 복합 인덱스 생성\nCREATE INDEX idx_orders_created_user \n    ON orders(created_at DESC, user_id);\n\n-- 해결 2: 테이블 파티셔닝 (월별)\nCREATE TABLE orders (\n    id NUMBER PRIMARY KEY,\n    user_id NUMBER NOT NULL,\n    created_at DATE NOT NULL,\n    total_amount NUMBER(10,2)\n) \nPARTITION BY RANGE (created_at) (\n    PARTITION orders_2024_01 VALUES LESS THAN (DATE '2024-02-01'),\n    PARTITION orders_2024_02 VALUES LESS THAN (DATE '2024-03-01'),\n    -- ... 월별 파티션\n);\n\n-- 결과: 15초 → 0.3초 (98% 개선)\n-- 파티션 프루닝으로 스캔 범위 1/12 축소\n```\n\n**Redis Sentinel HA 클러스터 운영:**\n\n세션 관리와 캐싱에서 Redis 장애가 비즈니스에 미치는 영향을 경험:\n\n```python\n# Redis Sentinel 설정\nimport redis.sentinel\n\n# Sentinel nodes (3개 노드로 고가용성 보장)\nsentinels = [\n    ('sentinel-1', 26379),\n    ('sentinel-2', 26379),\n    ('sentinel-3', 26379)\n]\n\nsentinel = redis.sentinel.Sentinel(sentinels, socket_timeout=0.1)\n\nclass CacheManager:\n    def __init__(self):\n        self.master = sentinel.master_for(\n            'mymaster', \n            socket_timeout=0.1, \n            password='secret',\n            decode_responses=True\n        )\n        self.slave = sentinel.slave_for(\n            'mymaster',\n            socket_timeout=0.1,\n            password='secret', \n            decode_responses=True\n        )\n    \n    def get_with_fallback(self, key):\n        try:\n            # 읽기는 slave에서 (읽기 부하 분산)\n            return self.slave.get(key)\n        except redis.ConnectionError:\n            # Slave 장애 시 master에서 읽기\n            return self.master.get(key)\n        except Exception:\n            # Redis 전체 장애 시 DB 직접 조회\n            return self.fallback_to_database(key)\n```\n\n**Cache-aside vs Write-through 패턴 선택:**\n\n```python\n# Cache-aside (읽기 중심 워크로드)\nclass UserService:\n    def get_user_profile(self, user_id):\n        cache_key = f'user:{user_id}'\n        \n        # 1. 캐시에서 먼저 조회\n        cached_user = cache.get(cache_key)\n        if cached_user:\n            return json.loads(cached_user)\n        \n        # 2. 캐시 미스 시 DB 조회\n        user = User.objects.get(id=user_id)\n        \n        # 3. 캐시에 저장 (TTL 1시간)\n        cache.setex(cache_key, 3600, json.dumps(user.to_dict()))\n        \n        return user\n\n# Write-through (일관성 중요)\nclass OrderService:\n    def create_order(self, order_data):\n        # 1. DB에 먼저 저장\n        order = Order.objects.create(**order_data)\n        \n        # 2. 캐시도 동시 업데이트\n        cache_key = f'order:{order.id}'\n        cache.setex(cache_key, 3600, json.dumps(order.to_dict()))\n        \n        # 3. 관련 캐시 무효화\n        cache.delete_pattern(f'user:{order.user_id}:orders:*')\n        \n        return order\n```\n\n**PostgreSQL: Airflow 메타데이터 DB 최적화**\n\n```sql\n-- 문제: DAG 실행 이력 쿼리 느림\n-- Airflow의 dag_run 테이블이 1000만+ 레코드\n\n-- 해결: 파티셔닝 + 인덱스 최적화\nCREATE TABLE dag_run_partitioned (\n    LIKE dag_run INCLUDING ALL\n) PARTITION BY RANGE (execution_date);\n\n-- 월별 파티션 생성\nCREATE TABLE dag_run_2024_01 PARTITION OF dag_run_partitioned\n    FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');\n\n-- 복합 인덱스 (가장 자주 사용되는 쿼리 패턴 기반)\nCREATE INDEX CONCURRENTLY idx_dag_run_dag_state_exec\n    ON dag_run_partitioned (dag_id, state, execution_date DESC);\n\n-- 결과: Airflow 웹 UI 응답속도 10초 → 1초\n```\n\n**AWS Athena + Parquet: 데이터 웨어하우스 최적화**\n\n대용량 로그 분석에서 비용과 성능 최적화:\n\n```sql\n-- 파티션 설계 (년/월/일/시간 계층)\nCREATE EXTERNAL TABLE otel_logs (\n    trace_id string,\n    span_id string,\n    severity string,\n    message string,\n    attributes map<string,string>\n)\nPARTITIONED BY (\n    year int,\n    month int, \n    day int,\n    hour int\n)\nSTORED AS PARQUET\nLOCATION 's3://analytics-bucket/logs/'\n\n-- 최적화된 쿼리 (파티션 프루닝 활용)\nSELECT \n    COUNT(*) as error_count,\n    attributes['service.name'] as service\nFROM otel_logs \nWHERE year = 2024 \n    AND month = 11 \n    AND day = 12\n    AND severity = 'ERROR'\nGROUP BY attributes['service.name']\nORDER BY error_count DESC;\n\n-- 비용 최적화 결과:\n-- 스캔 데이터: 10TB → 100GB (파티션 프루닝)\n-- 쿼리 비용: $50 → $5 (90% 절감)\n```\n\n**ClickHouse: 실시간 분석용 OLAP**\n\n```sql\n-- 실시간 API 메트릭 저장\nCREATE TABLE api_metrics (\n    timestamp DateTime,\n    service_name String,\n    endpoint String,\n    method String,\n    response_time_ms UInt32,\n    status_code UInt16\n) ENGINE = MergeTree()\nORDER BY (service_name, toYYYYMMDD(timestamp), timestamp);\n\n-- P95 응답시간 계산 (1초 내 응답)\nSELECT \n    service_name,\n    endpoint,\n    quantile(0.95)(response_time_ms) as p95_response_time\nFROM api_metrics \nWHERE timestamp >= now() - INTERVAL 1 HOUR\nGROUP BY service_name, endpoint\nORDER BY p95_response_time DESC;\n\n-- 압축률: 10:1 (LZ4), 쿼리 성능: 평균 100ms\n```\n\n**Database 선택 기준 (Production 경험 기반):**\n\n```\n┌─────────────┬─────────────┬─────────────┬─────────────┐\n│ Use Case    │ Database    │ Reason      │ Trade-off   │\n├─────────────┼─────────────┼─────────────┼─────────────┤\n│ OLTP        │ PostgreSQL  │ ACID + JSON │ Write 성능  │\n│ Session     │ Redis       │ 메모리 속도  │ 휘발성      │\n│ Analytics   │ ClickHouse  │ 컬럼형 압축  │ 복잡성      │\n│ Data Lake   │ Athena      │ 비용 효율   │ 지연시간    │\n└─────────────┴─────────────┴─────────────┴─────────────┘\n```\n\n핵심 교훈: **'데이터의 생명주기'를 고려한 multi-database 전략이 단일 DB보다 효율적**입니다.",
  },
  {
    id: 35,
    category1: "Backend",
    category2: "API Design",
    question: "What is your API design philosophy?",
    answer:
      '**API 설계에서 가장 중요한 것은 \'클라이언트의 사용 패턴을 먼저 이해\'하는 것입니다.**\n\n**REST vs GraphQL vs gRPC 선택 딜레마:**\n\n**Inoutbox POS 시스템 API 설계 경험:**\n\n```go\n// Go-Gin 기반 RESTful API\ntype ProductAPI struct {\n    service *ProductService\n}\n\n// 문제: N+1 문제를 API 레벨에서 해결\nfunc (api *ProductAPI) GetProducts(c *gin.Context) {\n    // 클라이언트별 필요 데이터가 다름\n    includes := c.Query("include") // "category,supplier,inventory"\n    \n    products, err := api.service.GetProductsWithIncludes(\n        c.Query("store_id"),\n        strings.Split(includes, ",")\n    )\n    \n    if err != nil {\n        c.JSON(500, gin.H{"error": "internal server error"})\n        return\n    }\n    \n    // 조건부 응답 구조\n    response := make(map[string]interface{})\n    response["products"] = products\n    \n    if strings.Contains(includes, "category") {\n        response["categories"] = api.getCategoriesForProducts(products)\n    }\n    \n    c.JSON(200, response)\n}\n\n// 결과: 단일 API로 다양한 클라이언트 요구사항 대응\n// 모바일: include="basic" (최소 데이터)\n// 웹: include="category,inventory" (상세 데이터)\n```\n\n**GraphQL 검토 과정과 포기 이유:**\n\n```javascript\n// GraphQL 검토안 (구현하지 않음)\ntype Query {\n  products(storeId: ID!, filter: ProductFilter): [Product!]!\n}\n\ntype Product {\n  id: ID!\n  name: String!\n  price: Float!\n  category: Category    # N+1 resolver 문제 여전히 존재\n  inventory: Inventory  # Database join 복잡도 증가\n}\n\n// 포기 이유:\n// 1. POS 시스템은 정형화된 화면 → REST로 충분\n// 2. GraphQL resolver 복잡도 vs 성능 gain 트레이드오프\n// 3. 팀 러닝커브 (Go GraphQL 생태계 미성숙)\n```\n\n**API 버전 관리 전략:**\n\n```go\n// URL 버전 vs Header 버전 고민\n// 선택: URL 버전 (캐싱, 디버깅 용이성)\n\nfunc setupRoutes(r *gin.Engine) {\n    // v1: 초기 버전\n    v1 := r.Group("/api/v1")\n    v1.GET("/products", api.v1.GetProducts)\n    \n    // v2: breaking change (response 구조 변경)\n    v2 := r.Group("/api/v2")\n    v2.GET("/products", api.v2.GetProducts)\n    \n    // 하위 호환성 유지 (6개월 deprecation 기간)\n}\n\n// 점진적 마이그레이션\ntype ProductResponseV1 struct {\n    ID    int    `json:"id"`\n    Name  string `json:"name"`\n    Price float64 `json:"price"`\n}\n\ntype ProductResponseV2 struct {\n    ID       int                    `json:"id"`\n    Name     string                 `json:"name"`\n    Pricing  PricingInfo           `json:"pricing"`  // 구조 변경\n    Metadata map[string]interface{} `json:"metadata"`  // 확장성\n}\n```\n\n**Error Handling 표준화:**\n\n```go\n// RFC 7807 Problem Details 기반\ntype APIError struct {\n    Type     string            `json:"type"`\n    Title    string            `json:"title"`\n    Status   int              `json:"status"`\n    Detail   string            `json:"detail"`\n    Instance string            `json:"instance"`\n    TraceID  string            `json:"trace_id"`\n    Context  map[string]interface{} `json:"context,omitempty"`\n}\n\n// 미들웨어에서 일관된 에러 처리\nfunc ErrorMiddleware() gin.HandlerFunc {\n    return gin.CustomRecovery(func(c *gin.Context, recovered interface{}) {\n        traceID := c.GetHeader("X-Trace-ID")\n        \n        var apiErr APIError\n        \n        switch err := recovered.(type) {\n        case *ValidationError:\n            apiErr = APIError{\n                Type:     "https://api.inoutbox.com/errors/validation",\n                Title:    "Validation Failed",\n                Status:   400,\n                Detail:   err.Message,\n                Instance: c.Request.URL.Path,\n                TraceID:  traceID,\n                Context:  map[string]interface{}{"fields": err.Fields},\n            }\n        case *NotFoundError:\n            apiErr = APIError{\n                Type:    "https://api.inoutbox.com/errors/not-found",\n                Title:   "Resource Not Found",\n                Status:  404,\n                Detail:  err.Message,\n                TraceID: traceID,\n            }\n        default:\n            // 내부 에러는 상세정보 숨김\n            apiErr = APIError{\n                Type:    "https://api.inoutbox.com/errors/internal",\n                Title:   "Internal Server Error",\n                Status:  500,\n                Detail:  "An unexpected error occurred",\n                TraceID: traceID,\n            }\n            \n            // 로깅 (Sentry, CloudWatch)\n            logger.Error("API Error", \n                "trace_id", traceID,\n                "error", fmt.Sprintf("%+v", err),\n                "path", c.Request.URL.Path)\n        }\n        \n        c.JSON(apiErr.Status, apiErr)\n    })\n}\n```\n\n**Rate Limiting + Circuit Breaker:**\n\n```go\n// Token bucket + sliding window\nfunc RateLimitMiddleware(rps int) gin.HandlerFunc {\n    limiter := rate.NewLimiter(rate.Limit(rps), rps*2)\n    \n    return func(c *gin.Context) {\n        clientIP := c.ClientIP()\n        \n        // IP별 제한\n        if !limiter.Allow() {\n            c.JSON(429, APIError{\n                Type:   "https://api.inoutbox.com/errors/rate-limit",\n                Title:  "Rate Limit Exceeded",\n                Status: 429,\n                Detail: fmt.Sprintf("Rate limit: %d requests per second", rps),\n            })\n            c.Abort()\n            return\n        }\n        \n        c.Next()\n    }\n}\n\n// Circuit breaker (외부 API 호출)\nfunc (api *PaymentAPI) ProcessPayment(c *gin.Context) {\n    breaker := circuitbreaker.New("payment-service", 5, time.Minute)\n    \n    result, err := breaker.Execute(func() (interface{}, error) {\n        return api.paymentClient.Charge(paymentRequest)\n    })\n    \n    if err == circuitbreaker.ErrCircuitOpen {\n        c.JSON(503, APIError{\n            Type:   "https://api.inoutbox.com/errors/service-unavailable",\n            Title:  "Payment Service Unavailable",\n            Status: 503,\n            Detail: "Payment service is temporarily unavailable",\n        })\n        return\n    }\n    \n    c.JSON(200, result)\n}\n```\n\n**OpenAPI 3.0 + Code Generation:**\n\n```yaml\n# api.yaml - OpenAPI 스펙\nopenapi: 3.0.3\ninfo:\n  title: Inoutbox POS API\n  version: 2.1.0\npaths:\n  /api/v2/products:\n    get:\n      parameters:\n        - name: include\n          in: query\n          schema:\n            type: string\n            enum: ["category", "inventory", "supplier"]\n      responses:\n        \'200\':\n          content:\n            application/json:\n              schema:\n                $ref: \'#/components/schemas/ProductListResponse\'\n        \'400\':\n          content:\n            application/problem+json:\n              schema:\n                $ref: \'#/components/schemas/APIError\'\n```\n\n**실제 프로덕션에서의 API 진화:**\n\n**초기 (v1.0)**: 단순 CRUD REST API\n→ **문제**: Frontend별 다른 요구사항\n\n**개선 (v2.0)**: Flexible include 패러미터\n→ **문제**: 복잡한 쿼리 파라미터\n\n**현재 (v2.1)**: BFF (Backend for Frontend) 패턴\n```go\n// 클라이언트별 최적화된 엔드포인트\n/api/v2/mobile/dashboard     // 모바일 대시보드용\n/api/v2/web/inventory        // 웹 재고관리용\n/api/v2/kiosk/orders         // 키오스크 주문용\n```\n\n**6개월 운영 성과:**\n- **API 응답시간**: P95 기준 2.1초 → 0.4초\n- **에러율**: 5.2% → 0.3%\n- **개발 생산성**: 새 기능 개발 시간 40% 단축\n\n핵심 교훈: **API는 \'클라이언트와 서버 사이의 계약\'이므로 변경 비용을 최소화하는 설계가 중요**합니다.',
  },
  {
    id: 40,
    category1: "Backend",
    category2: "Testing",
    question: "What is your testing strategy?",
    answer:
      "**테스트 전략에서 가장 중요한 것은 '장애 비용 vs 테스트 비용'의 균형입니다.**\n\n**Testing Pyramid를 실제 프로덕션에 적용한 경험:**\n\n```\n     /\\     E2E Tests (5%)          \n    /  \\    - 핵심 비즈니스 플로우\n   /____\\   - 결제, 주문 완료\n  /      \\  \n /________\\ Integration Tests (25%)\n/          \\ - API 계약 테스트\n____________ Unit Tests (70%)\n              - 비즈니스 로직 검증\n```\n\n**Unit Tests: 비즈니스 로직 중심 접근**\n\n```go\n// 주문 할인 로직 - 복잡한 비즈니스 룰\nfunc TestOrderDiscountCalculation(t *testing.T) {\n    tests := []struct {\n        name           string\n        order          Order\n        customer       Customer\n        expectedDiscount float64\n    }{\n        {\n            name: \"VIP 고객 + 대량구매 + 첫 주문\",\n            order: Order{\n                Items: []Item{\n                    {ProductID: 1, Quantity: 100, UnitPrice: 1000},\n                },\n                TotalAmount: 100000,\n            },\n            customer: Customer{\n                Tier: \"VIP\",\n                IsFirstOrder: true,\n            },\n            expectedDiscount: 25000, // 20% VIP + 5% 첫주문\n        },\n        {\n            name: \"일반 고객 + 소량구매\",\n            order: Order{\n                Items: []Item{\n                    {ProductID: 1, Quantity: 1, UnitPrice: 1000},\n                },\n                TotalAmount: 1000,\n            },\n            customer: Customer{Tier: \"NORMAL\"},\n            expectedDiscount: 0,\n        },\n    }\n    \n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            calculator := NewDiscountCalculator()\n            discount := calculator.Calculate(tt.order, tt.customer)\n            \n            assert.Equal(t, tt.expectedDiscount, discount,\n                \"할인 계산이 예상과 다릅니다\")\n        })\n    }\n}\n\n// 테스트 커버리지: 비즈니스 로직 95% 이상 유지\n// go test -coverprofile=coverage.out\n// go tool cover -html=coverage.out\n```\n\n**Integration Tests: Contract Testing**\n\n```python\n# Django REST API 통합 테스트\nclass OrderAPIIntegrationTest(APITestCase):\n    def setUp(self):\n        self.factory = APIRequestFactory()\n        self.user = User.objects.create_user(\n            username='test@example.com',\n            password='testpass123'\n        )\n        \n    def test_create_order_with_payment_integration(self):\n        \"\"\"실제 결제 API와 통합 테스트 (Mocking 아님)\"\"\"\n        \n        # Given: 실제 테스트 결제 키 사용\n        payment_data = {\n            'card_number': '4111111111111111',  # 테스트 카드\n            'amount': 10000,\n            'currency': 'KRW'\n        }\n        \n        # When: 주문 + 결제 API 호출\n        response = self.client.post('/api/orders/', {\n            'items': [{'product_id': 1, 'quantity': 2}],\n            'payment': payment_data\n        })\n        \n        # Then: 전체 플로우 검증\n        self.assertEqual(response.status_code, 201)\n        \n        order = Order.objects.get(id=response.data['id'])\n        self.assertEqual(order.status, 'PAID')\n        \n        # 실제 결제 상태 확인\n        payment = Payment.objects.get(order=order)\n        self.assertEqual(payment.status, 'SUCCESS')\n        \n        # 재고 차감 확인\n        product = Product.objects.get(id=1)\n        self.assertEqual(product.stock, 98)  # 초기 100 - 주문 2\n        \n    @patch('payments.PaymentGateway.charge')\n    def test_payment_failure_rollback(self, mock_charge):\n        \"\"\"결제 실패 시 롤백 테스트\"\"\"\n        \n        # Given: 결제 실패 시뮬레이션\n        mock_charge.side_effect = PaymentException(\"카드 승인 실패\")\n        \n        # When: 주문 시도\n        response = self.client.post('/api/orders/', {\n            'items': [{'product_id': 1, 'quantity': 2}],\n            'payment': {'card_number': '4111111111111111'}\n        })\n        \n        # Then: 트랜잭션 롤백 확인\n        self.assertEqual(response.status_code, 400)\n        self.assertEqual(Order.objects.count(), 0)  # 주문 생성 안됨\n        \n        product = Product.objects.get(id=1)\n        self.assertEqual(product.stock, 100)  # 재고 차감 안됨\n```\n\n**End-to-End Tests: Cypress + Real Browser**\n\n```javascript\n// 핵심 비즈니스 플로우만 E2E 테스트\ndescribe('주문 완료 플로우', () => {\n  beforeEach(() => {\n    // 테스트 데이터 초기화\n    cy.task('db:seed');\n    cy.login('test-user@example.com', 'password123');\n  });\n\n  it('상품 선택 → 장바구니 → 결제 → 주문완료', () => {\n    // Given: 상품 페이지 방문\n    cy.visit('/products/laptop-pro');\n    \n    // When: 상품을 장바구니에 추가\n    cy.get('[data-testid=\"add-to-cart\"]').click();\n    cy.get('[data-testid=\"cart-count\"]').should('contain', '1');\n    \n    // 장바구니로 이동\n    cy.get('[data-testid=\"cart-icon\"]').click();\n    cy.url().should('include', '/cart');\n    \n    // 결제 프로세스\n    cy.get('[data-testid=\"checkout-button\"]').click();\n    \n    // 결제 정보 입력 (실제 테스트 카드)\n    cy.get('#card-number').type('4111111111111111');\n    cy.get('#expiry').type('12/25');\n    cy.get('#cvv').type('123');\n    \n    // 주문 완료\n    cy.get('[data-testid=\"place-order\"]').click();\n    \n    // Then: 성공 페이지 확인\n    cy.url().should('include', '/order-success');\n    cy.get('[data-testid=\"order-number\"]').should('be.visible');\n    \n    // 이메일 발송 확인 (MailHog 테스트 메일서버)\n    cy.task('mailhog:getLatestEmail').then((email) => {\n      expect(email.subject).to.contain('주문이 완료되었습니다');\n    });\n  });\n  \n  it('결제 실패 시 사용자 경험', () => {\n    // 잘못된 카드 정보로 결제 시도\n    cy.visit('/cart');\n    cy.get('[data-testid=\"checkout-button\"]').click();\n    cy.get('#card-number').type('4000000000000002'); // 거절되는 테스트 카드\n    \n    cy.get('[data-testid=\"place-order\"]').click();\n    \n    // 에러 메시지 확인\n    cy.get('[data-testid=\"payment-error\"]')\n      .should('be.visible')\n      .and('contain', '카드가 거절되었습니다');\n      \n    // 장바구니 상태 유지 확인\n    cy.get('[data-testid=\"cart-items\"]').should('be.visible');\n  });\n});\n```\n\n**Load Testing: K6 스크립트**\n\n```javascript\n// load-test.js\nimport http from 'k6/http';\nimport { check, sleep } from 'k6';\n\nexport let options = {\n  stages: [\n    { duration: '2m', target: 100 },   // 2분간 100 사용자로 램프업\n    { duration: '5m', target: 100 },   // 5분간 100 사용자 유지\n    { duration: '2m', target: 200 },   // 2분간 200 사용자로 증가\n    { duration: '5m', target: 200 },   // 5분간 200 사용자 유지\n    { duration: '2m', target: 0 },     // 2분간 0으로 감소\n  ],\n  thresholds: {\n    http_req_duration: ['p(95)<2000'],   // 95%가 2초 이내\n    http_req_failed: ['rate<0.1'],       // 실패율 10% 미만\n  },\n};\n\nexport default function () {\n  // 실제 사용자 시나리오 시뮬레이션\n  let response = http.get('https://api.inoutbox.com/products');\n  check(response, {\n    'status is 200': (r) => r.status === 200,\n    'response time < 1s': (r) => r.timings.duration < 1000,\n  });\n  \n  // 주문 생성 API\n  let orderPayload = JSON.stringify({\n    items: [{ product_id: 1, quantity: Math.floor(Math.random() * 5) + 1 }]\n  });\n  \n  let orderResponse = http.post(\n    'https://api.inoutbox.com/orders',\n    orderPayload,\n    { headers: { 'Content-Type': 'application/json' } }\n  );\n  \n  check(orderResponse, {\n    'order created': (r) => r.status === 201,\n  });\n  \n  sleep(1); // 사용자 행동 시뮬레이션\n}\n\n// 실행: k6 run load-test.js\n// 결과: P95 응답시간 1.2초, 실패율 0.05%\n```\n\n**Chaos Engineering: 장애 내성 테스트**\n\n```python\n# chaos_test.py - 의존성 장애 시뮬레이션\nfrom chaoslib.experiments import run_experiment\nimport pytest\nimport requests\nimport time\n\nclass ChaosTest:\n    def test_database_connection_failure(self):\n        \"\"\"DB 연결 장애 시 API 동작 확인\"\"\"\n        \n        # Given: 정상 상태 확인\n        response = requests.get('http://localhost:8000/api/health')\n        assert response.status_code == 200\n        \n        # When: DB 연결 차단 (Docker network 조작)\n        self.block_database_connection()\n        \n        try:\n            # Then: Graceful degradation 확인\n            response = requests.get('http://localhost:8000/api/products')\n            \n            # 캐시에서 응답 (성능은 떨어지지만 서비스는 유지)\n            assert response.status_code == 200\n            assert 'cached' in response.headers.get('X-Data-Source', '')\n            \n            # 쓰기 작업은 적절히 실패\n            order_response = requests.post(\n                'http://localhost:8000/api/orders',\n                json={'items': [{'product_id': 1, 'quantity': 1}]}\n            )\n            assert order_response.status_code == 503\n            assert 'temporarily unavailable' in order_response.json()['detail']\n            \n        finally:\n            # 연결 복구\n            self.restore_database_connection()\n            \n        # 복구 후 정상 동작 확인\n        time.sleep(5)  # 연결 풀 복구 대기\n        response = requests.get('http://localhost:8000/api/health')\n        assert response.status_code == 200\n```\n\n**CI/CD 통합: GitHub Actions**\n\n```yaml\n# .github/workflows/test.yml\nname: Test Suite\n\non: [push, pull_request]\n\njobs:\n  unit-tests:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - name: Setup Go\n        uses: actions/setup-go@v2\n        with:\n          go-version: 1.19\n      \n      - name: Run Unit Tests\n        run: |\n          go test -v -coverprofile=coverage.out ./...\n          go tool cover -html=coverage.out -o coverage.html\n      \n      - name: Coverage Gate\n        run: |\n          COVERAGE=$(go tool cover -func=coverage.out | grep total | awk '{print $3}' | sed 's/%//')\n          echo \"Coverage: $COVERAGE%\"\n          if (( $(echo \"$COVERAGE < 80\" | bc -l) )); then\n            echo \"Coverage below 80%\"\n            exit 1\n          fi\n  \n  integration-tests:\n    runs-on: ubuntu-latest\n    services:\n      postgres:\n        image: postgres:13\n        env:\n          POSTGRES_PASSWORD: postgres\n        options: >-\n          --health-cmd pg_isready\n          --health-interval 10s\n          --health-timeout 5s\n          --health-retries 5\n    \n    steps:\n      - name: Run Integration Tests\n        run: make test-integration\n  \n  e2e-tests:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Run E2E Tests\n        run: |\n          docker-compose -f docker-compose.test.yml up -d\n          npm run cypress:run\n          docker-compose -f docker-compose.test.yml down\n```\n\n**실제 프로덕션 테스트 성과:**\n\n- **배포 신뢰도**: 테스트 도입 전 장애율 15% → 도입 후 2%\n- **버그 발견 시점**: 프로덕션 60% → 개발단계 85%\n- **배포 속도**: 2주 → 1일 (자동화된 테스트 신뢰도)\n\n핵심 교훈: **'완벽한 테스트'보다 '비용 대비 효과적인 테스트 전략'이 중요**합니다.",
  },
];
